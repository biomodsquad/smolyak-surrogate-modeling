import abc
import numpy


class UnidimensionalPointSet(abc.ABC):
    """Set of unidimensional points

    A set of unique unidimensional points to be used as the sampling points
    in a tensor product grid or sparse grid. These unidimensional points are
    associated with certain polynomial families, and the combination of
    unique points and polynomial families are the basis for different types
    of quadrature rules that are used in numerical integration and in
    approximation.
    The natural domain of the points specified by :param:``domain`` is
    the domain in which all the possible points in the set lies within.
    ``points`` is the list of points that the UnidimensionalPointSet
    is expected to store.
    ``domain`` is the domain of the points generated by the point set.
    """

    def __init__(self):
        self._points = None
        self._valid_cache = True

    @property
    @abc.abstractmethod
    def domain(self):
        """list: Domain the sample points come from."""
        pass

    @property
    def points(self):
        """list: Points stored by the set."""
        if self._valid_cache:
            self._create()
        self._valid_cache = False
        return self._points

    @abc.abstractmethod
    def _create(self):
        r"""Generating the points

        An abstract method for generating the points stored by the point set
        and other parameters.
        """
        pass


class NestedUnidimensionalPointSet(UnidimensionalPointSet):
    """Set of unidimensional points with levels

    A set of unique unidimensional points to be used as the sampling points
    in a tensor product grid or sparse grid. These unidimensional points are
    associated with certain polynomial families, and the combination of
    unique points and polynomial families are the basis for different types
    of quadrature rules that are used in numerical integration and in
    approximation.

    The number of unique points is controlled by `levels`, where at each
    new level more points are added. The amount of points added by each level
    is determined via a growth scheme related to the polynomial familiy.
    `points` describes the unique points added as the number of levels increase,
    and the order of elements is reflective of the level each element first
    appears in. Some point set are nested, meaning that the points in a previous
    level reappear in following levels. However, `points` does not attempt to
    capture this behavior and should be free of duplicates.
    `levels` describes the number of points in each level and assigns each
    a set of indices of elements in `points`.

    Parameters
    ----------
    max_level ; int
        the maximum level the points are used for
    """

    def __init__(self, max_level):
        super().__init__()
        self.max_level = max_level
        self._levels = None

    @property
    def max_level(self):
        """int: maximum level to compute points for."""
        return self._max_level

    @max_level.setter
    def max_level(self, value):
        self._max_level = value
        self._valid_cache = True

    @property
    def levels(self):
        """list: level indices stored by the set."""
        if self._valid_cache:
            self._create()
        self._valid_cache = False
        return self._levels

    @abc.abstractmethod
    def _new_per_level(self, level):
        r"""A vector describing the number of new points per level

        Returns a vector with the number of new unique points per level 
        specified by the growth scheme that the point set describes.

        Certain growth rules such as exponential, slow exponential, linear,
        etc. specify the growth order of a polynomial family. The number of
        points added per level depends on this order. The number of unique
        points is additionally dependent on the nestedness of the level

        A fully nested point set has every level contain all the
        points of the previous levels, a weakly nested point set has the 
        point 0 recur in each level, a very weakly nested point set has the 
        point 0 recur only in some levels, and a nonnested point set has no
        repeating points in any level.
        
        For a fully nested point set, the relationship between the order and 
        the number of new unique points per level L is 
        :math..

        n(L) = \begin{cases}
            gr(L) - gr(L-1)) & \text{ if } L > 0 \\ 
            1 & \text{ if } L = 0
            \end{cases}
        
        For a non-nested point set, the relationship between the order and 
        the number of new points per level L is 
        :math..

        n(L) = \begin{cases}
            gr(L)& \text{ if } L > 0 \text{ and }gr(L) - gr(L-1) > 0 \\ 
            0 & \text{ if } L > 0 \text{ and }gr(L) - gr(L-1) = 0 \\ 
            1 & \text{ if } L= 0
            \end{cases}

        For a weakly nested point set with 1 point recurring each level, the
        relationship is 
        :math..

        n(L) = \begin{cases}
            gr(L) - 1 & \text{ if } L > 0 \text{ and }gr(L) - gr(L-1) > 0 \\ 
            0 & \text{ if } L > 0 \text{ and }gr(L) - gr(L-1) = 0 \\ 
            1 & \text{ if } L= 0
            \end{cases}

        For a very weakly nested point set, the relationship between the 
        growth order and the number of unique new points per level depends
        on which levels have recurring points. Additionally, certain polynomial
        families such as Gauss-Patterson are not known to extend to infinite
        levels or are known to be finite.

        Parameters
        ----------
        level : int
            the given level

        Returns
        -------
        list
            the number of new unique points added each level
        """
        pass

    def _create(self):
        r"""Generating the points and levels

        Generating the points stored by the point set and the levels.
        """
        self._create_points()
        self._create_levels()
        

    @abc.abstractmethod
    def _create_points(self):
        r"""Generating the points stored by the point set."""
        pass

    def _create_levels(self):
        r"""Generating the levels stored by the point set. 
        
        The levels of the point set describes what points go into each level
        and how many. This amount is determined by both the polynomial family
        and by the growth scheme. Determining the number of unique points in 
        each level is handled by :meth:`_new_per_level`
        """
        new_vector = self._new_per_level(self.max_level)
        acc = numpy.cumsum([0] + new_vector)
        levels = [
            list(range(acc[i], new_vector[i] + acc[i])) for i in range(len(new_vector))
        ]
        self._levels = levels


class ClenshawCurtisPointSet(UnidimensionalPointSet):
    r"""Set of unidimensional points for Clenshaw Curtis sampling

    The :attr:`points` for this interpolation scheme are the extrema of the
    Chebyshev polynomials of the first kind on the domain :math:`[-1, 1]`:

    .. math::

        x_i^* = -\cos(\pi i/n), i = 0,...,n

    For the special case :math:`n = 0`, there is only one point :math:`x_0^* = 0`.

    Parameters
    ----------
    degree : int
        degree of the Chebyshev polynomial of the first kind to get extrema from
    """

    def __init__(self, degree):
        super().__init__()
        self.degree = degree

    @property
    def domain(self):
        """numpy.ndarray: Domain the sample points come from."""
        return numpy.array([-1, 1])

    @property
    def degree(self):
        """int: degree of polynomial to create points for."""
        return self._degree

    @degree.setter
    def degree(self, value):
        self._degree = value
        self._valid_cache = True

    def _create(self):
        r"""Generating the points

        Generating the extrema of a Cheybshev polynomial of the first kind at
        a given degree.
        """
        if self.degree > 0:
            points = -numpy.cos(
                numpy.pi * numpy.linspace(0, self.degree, self.degree + 1) / self.degree
            )
        else:
            points = numpy.zeros(1)
        self._points = points


class NestedClenshawCurtisPointSet(NestedUnidimensionalPointSet):
    r"""Generate nested Clenshaw Curtis points in accordance with a growth rule

    The :attr:`points` for this interpolation scheme are the extrema of the
    Chebyshev polynomials of the first kind on the domain :math:`[-1, 1]`:

    .. math::

        x_i^* = -\cos(\pi i/n), i = 0,...,n

    For the special case :math:`n = 0`, there is only one point :math:`x_0^* = 0`.

    The nested Clenshaw Curtis points come from the nested extrema of the
    Chebyshev polynomials of the first kind :math:0, 2, 2^{k} where k is an
    integer.

    These extrema are symmetric about 0. When generating levels of points, each
    level with contain a certain number of symmetric pairs except the first which
    also includes 0. The number of points assigned to each level can vary.
    The default, exponential growth adds points such that the new extrema
    calculated from a Chebyshev polynomial 2^{k} is given its own level k-1.
    Alternative growth rules may delay the addition of new extrema and have
    intermediary empty levels, but the general order that points are added to
    levels remains the same.

    This class will generate the nested extrema in the order that corresponds
    to the exponential growth. For increasing k, the unique extrema of Chebyshev
    polynomial with degree 2^{k - 1} will be added followed by the extrema of the
    polynomial with degree 2^{k} , then 2^{k + 1} , then 2^{k + 2} and so on.

    Parameters
    ----------
    max_level ; int
        the maximum level the points are used for
    """

    def __init__(self, max_level):
        super().__init__(max_level)

    @property
    def domain(self):
        """numpy.ndarray: Domain the sample points come from."""
        return numpy.array([-1, 1])

    def _new_per_level(self, level):
        r"""A vector describing the number of new points per level

        Returns a vector with the number of new unique points per level 
        specified by the growth scheme that the point set describes.

        The Clenshaw Curtis point set is by default experiences exponential
        growth of 1D unique points. It's growth order is described as

        .. math::
        o(L) = \begin{cases}
            1 & \text{ if } L=0 \\ 
            2^{L}+1 & \text{ if } L>0 
        \end{cases}
        
        The polynomial family is fully nested, so the relationship between
        this growth order and the number of new points per level is
        .. math::
        n(L) = \begin{cases}
            gr(L) - gr(L-1)) & \text{ if } L > 0 \\ 
            1 & \text{ if } L = 0
        \end{cases}

        Parameters
        ----------
        level : int
            the given level

        Returns
        -------
        list
            the number of new unique points added each level
        """
        rule = lambda x: 1 if x == 0 else 2**x + 1
        return [rule(0)] + [rule(i)-rule(i-1) for i in range(1,level+1)]

    def _create_points(self):
        r"""Generating the points

        Generating nested extrema of chebyshev polynomials of the first kind.
        """
        points = [0]
        degree = 0
        counter = 0
        new_vector = numpy.array(self._new_per_level(self.max_level))
        num_levels = numpy.sum(new_vector != 0)
        for i in range(1, num_levels):
            counter = counter + 1
            degree = 2**counter
            if counter == 1:
                indexes = numpy.linspace(0, degree, 2, dtype=int)
            else:
                indexes = numpy.linspace(1, degree - 1, degree - 1, dtype=int)
                indexes = indexes[~(numpy.gcd(indexes, degree) > 1)]
            new_points = list(-numpy.cos(numpy.pi * indexes / degree))
            points.extend(new_points)
        self._points = points

class SlowNestedClenshawCurtisPointSet(NestedClenshawCurtisPointSet):
    """Set for Clenshaw Curtis slow exponential growth"""

    def _new_per_level(self, level):
        r"""A vector describing the number of new points per level

        Returns a vector with the number of new unique points per level 
        specified by the growth scheme that the point set describes.

        The Clenshaw Curtis point set is by default experiences exponential
        growth of 1D unique points. This growth rule can be slowed down by
        delaying which points are added at which levels. This delay is 
        described by setting a "precision rule" of :math:2 * L + 1 where L 
        is the level. New unique points are added at levels where the 
        accumulated number of points is less than the precision rule. If the
        number of points accumulated is greater or equal to the precision rule,
        then no points are added at that level. The size and progression of
        the nonempty levels remains the same as the exponential growth case.  

        .. math::
        o(L) = \begin{cases}
            1 & \text{ if } L=0 \\ 
            2^{\left \lceil \log_{2}(L) \right \rceil+1}+1 & \text{ if } L>0 
        \end{cases}

        
        The polynomial family is fully nested, so the relationship between
        this growth order and the number of new points per level is
        .. math::
        n(L) = \begin{cases}
            gr(L) - gr(L-1)) & \text{ if } L > 0 \\ 
            1 & \text{ if } L = 0
            \end{cases}

        Parameters
        ----------
        level : int
            the given level

        Returns
        -------
        list
            the number of new unique points added each level
        """
        rule = lambda x : 1 if x==0 else int(2**(numpy.ceil(numpy.log2(x))+1) + 1)
        return [rule(0)] + [rule(i)-rule(i-1) for i in range(1,level+1)]

class TrigonometricPointSet(UnidimensionalPointSet):
    r"""Set of unidimensional points for Trigonometric sampling

    The :attr:`points` for this interpolation scheme are nested
    trigonometric points

    .. math::

        x^l_j = \frac{j-1}{m(l)},  1 \leq j \leq m(l), l \geq 0

    Parameters
    ----------
    frequency : int
        the frequency to take points from
    """

    def __init__(self, frequency):
        super().__init__()
        self.frequency = frequency

    @property
    def domain(self):
        """numpy.ndarray: Domain the sample points come from."""
        return numpy.array([0, 2 * numpy.pi])

    @property
    def frequency(self):
        """int: frequency to create points for."""
        return self._frequency

    @frequency.setter
    def frequency(self, value):
        self._frequency = value
        self._valid_cache = True

    def _create(self):
        r"""Generating the points

        Generating trigonometic points at a given frequency.
        """
        if self.frequency > 0:
            idx = numpy.linspace(1, self.frequency, self.frequency)
            points = (idx - 1) * 2 * numpy.pi / self.frequency
        else:
            points = numpy.zeros(1)
        self._points = points


class NestedTrigonometricPointSet(NestedUnidimensionalPointSet):
    r"""Set of unidimensional points for Trigonometric sampling

    The :attr:`points` for this interpolation scheme are nested
    trigonometric points

    .. math::

        x^l_j = \frac{j-1}{m(l)},  1 \leq j \leq m(l), l \geq 0

    These points are nested, such that the order of elements in
    `points` corresponds to the indices in `levels`.
    """

    def __init__(self, max_level):
        super().__init__(max_level)

    @property
    def domain(self):
        """numpy.ndarray: Domain the sample points come from."""
        return numpy.array([0, 2 * numpy.pi])
    
    def _new_per_level(self, level):
        r"""A vector describing the number of new points per level

        Returns a vector with the number of new unique points per level 
        specified by the growth scheme that the point set describes.

        The Trigonometric point set is by default experiences exponential
        growth of 1D unique points. The growth order of this set is 
        described as 
        .. math::
        o(L) = 3^{x}
        
        The polynomial family is fully nested, so the relationship between
        this growth order and the number of new points per level is
        .. math::
        n(L) = \begin{cases}
            gr(L) - gr(L-1)) & \text{ if } L > 0 \\ 
            1 & \text{ if } L = 0
            \end{cases}

        Parameters
        ----------
        level : int
            the given level

        Returns
        -------
        list
            the number of new unique points added each level
        """
        rule = lambda x: 3**x
        return [rule(0)] + [rule(i)-rule(i-1) for i in range(1,level+1)]
    
    def _create_points(self):
        r"""Generating the points

        Generating the trignometric points using the frequencies
        :math:1, 3, 9, ..., 3^{i} where i is an integer.
        """
        points = []
        degree = 0
        counter = 0
        for i in range(self.max_level + 1):
            degree = 3**counter
            for idx in range(1, degree + 1):
                point = (idx - 1) * 2 * numpy.pi / degree
                if not numpy.isclose(points, point).any():
                    points.append(point)
            counter += 1
        self._points = points
