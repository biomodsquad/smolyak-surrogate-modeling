import abc
import numpy


class UnidimensionalPointSet(abc.ABC):
    """Set of unidimensional points

    A set of unique unidimensional points to be used as the sampling points
    in a tensor product grid or sparse grid. These unidimensional points are
    associated with certain polynomial families, and the combination of
    unique points and polynomial families are the basis for different types
    of quadrature rules that are used in numerical integration and in
    approximation.
    The natural domain of the points specified by :param:``domain`` is
    the domain in which all the possible points in the set lies within.
    ``points`` is the list of points that the UnidimensionalPointSet
    is expected to store.
    ``domain`` is the domain of the points generated by the point set.
    """

    def __init__(self):
        self._points = None
        self._valid_cache = True

    @property
    @abc.abstractmethod
    def domain(self):
        """list: Domain the sample points come from."""
        pass

    @property
    def points(self):
        """list: Points stored by the set."""
        if self._valid_cache:
            self._create()
        self._valid_cache = False
        return self._points

    @abc.abstractmethod
    def _create(self):
        r"""Generating the points

        An abstract method for generating the points stored by the point set
        and other parameters.
        """
        pass


class TieredUnidimensionalPointSet(UnidimensionalPointSet):
    """Set of unidimensional points with levels

    A set of unique unidimensional points to be used as the sampling points
    in a tensor product grid or sparse grid. These unidimensional points are
    associated with certain polynomial families, and the combination of
    unique points and polynomial families are the basis for different types
    of quadrature rules that are used in numerical integration and in
    approximation.

    The number of unique points is controlled by `levels`, where at each
    new level more points are added. The amount of points added by each level
    is determined via a growth scheme related to the polynomial familiy.
    `points` describes the unique points added as the number of levels increase,
    and the order of elements is reflective of the level each element first
    appears in. Some point set are nested, meaning that the points in a previous
    level reappear in following levels. However, `points` does not attempt to
    capture this behavior and should be free of duplicates.
    `levels` describes the number of points in each level and assigns each
    a set of indices of elements in `points`.

    Parameters
    ----------
    max_level ; int
        the maximum level the points are used for
    """

    def __init__(self, max_level):
        super().__init__()
        self.max_level = max_level
        self._levels = None

    @property
    def max_level(self):
        """int: maximum level to compute points for."""
        return self._max_level

    @max_level.setter
    def max_level(self, value):
        self._max_level = value
        self._valid_cache = True

    @property
    def levels(self):
        """list: level indices stored by the set."""
        if self._valid_cache:
            self._create()
        self._valid_cache = False
        return self._levels

    @property
    @abc.abstractmethod
    def growth_order(self):
        """callable or list: the order of the growth rule."""
        pass

    @property
    @abc.abstractmethod
    def nestedness(self):
        """str: the type of nestedness of the point set."""
        pass

    def _growth_rule(self, level):
        """ "The order of the level

        Returns the order of the level according to the growth rule given
        by `growth_order`

        Parameters
        ----------
        level : int
            the given level

        Returns
        -------
        int
            the order at that level
        """
        if callable(self.growth_order):
            return self.growth_order(level)
        else:
            return self.growth_order[level]

    def _create(self):
        r"""Generating the points and levels

        Generating the points stored by the point set and the levels.
        """
        self._create_points()
        self._create_levels()

    @abc.abstractmethod
    def _create_points(self):
        r"""Generating the points stored by the point set."""
        pass

    def _create_levels(self):
        r"""Generating the levels stored by the point set. 
        
        The levels of the point set describes what points go into each level
        and how many. This amount is determined by both the polynomial family
        and by the growth scheme given by `growth_order`. Determining the
        number of points in each level varies depending on whether the 
        point set is fully nested, weakly nested, very weakly nested, or 
        non-nested. A fully nested point set has every level contain all the
        points of the previous levels, a weakly nested point set has the 
        point 0 recur in each level, a very weakly nested point set has the 
        point 0 recur only in some levels, and a nonnested point set has no
        repeating points in any level.
        
        For a fully nested point set, the relationship between the order and 
        the number of new unique points per level L is 
        :math..

        n(L) = \begin{cases}
            gr(L) - gr(L-1)) & \text{ if } L > 0 \\ 
            1 & \text{ if } L = 0
            \end{cases}
        
        For a non-nested point set, the relationship between the order and 
        the number of new points per level L is 
        :math..

        n(L) = \begin{cases}
            gr(L)& \text{ if } L > 0 \text{ and }gr(L) - gr(L-1) > 0 \\ 
            0 & \text{ if } L > 0 \text{ and }gr(L) - gr(L-1) = 0 \\ 
            1 & \text{ if } L= 0
            \end{cases}

        For a weakly nested point set with 1 point recurring each level, the
        relationship is 
        :math..

        n(L) = \begin{cases}
            gr(L) - 1 & \text{ if } L > 0 \text{ and }gr(L) - gr(L-1) > 0 \\ 
            0 & \text{ if } L > 0 \text{ and }gr(L) - gr(L-1) = 0 \\ 
            1 & \text{ if } L= 0
            \end{cases}

        For a very weakly nested set, this method should be overridden to
        specify which levels points recur.

        Raises
        ------
        NotImplementedError
            Cannot determine points per level for a very weakly nested set.
        ValueError
            Not a valid nestedness.
        """
        if self.nestedness == "fully":
            # new vector at index L is rule(L) - rule(L-1)
            new_vector = [self._growth_rule(0)] + [
                self._growth_rule(i) - self._growth_rule(i - 1)
                for i in range(1, self.max_level + 1)
            ]
        elif self.nestedness == "none":
            # new vector at index L is rule(L) if rule(L) - rule(L-1) != 0
            new_vector = [self._growth_rule(0)] + [
                (
                    self._growth_rule(i)
                    if self._growth_rule(i) - self._growth_rule(i - 1) != 0
                    else 0
                )
                for i in range(1, self.max_level + 1)
            ]
        elif self.nestedness == "weakly":
            # new vector at index L is rule(L) if rule(L) - rule(L-1) != 0
            new_vector = [self._growth_rule(0)] + [
                (
                    self._growth_rule(i) - 1
                    if self._growth_rule(i) - self._growth_rule(i - 1) != 0
                    else 0
                )
                for i in range(1, self.max_level + 1)
            ]
        elif self.nestedness == "very weakly":
            raise NotImplementedError()
        else:
            raise ValueError("Not a valid nestedness.")
        acc = numpy.cumsum([0] + new_vector)
        levels = [
            list(range(acc[i], new_vector[i] + acc[i])) for i in range(len(new_vector))
        ]
        self._levels = levels


class ClenshawCurtisPointSet(UnidimensionalPointSet):
    r"""Set of unidimensional points for Clenshaw Curtis sampling

    The :attr:`points` for this interpolation scheme are the extrema of the
    Chebyshev polynomials of the first kind on the domain :math:`[-1, 1]`:

    .. math::

        x_i^* = -\cos(\pi i/n), i = 0,...,n

    For the special case :math:`n = 0`, there is only one point :math:`x_0^* = 0`.

    Parameters
    ----------
    degree : int
        degree of the Chebyshev polynomial of the first kind to get extrema from
    """

    def __init__(self, degree):
        super().__init__()
        self.degree = degree

    @property
    def domain(self):
        """numpy.ndarray: Domain the sample points come from."""
        return numpy.array([-1, 1])

    @property
    def degree(self):
        """int: degree of polynomial to create points for."""
        return self._degree

    @degree.setter
    def degree(self, value):
        self._degree = value
        self._valid_cache = True

    def _create(self):
        r"""Generating the points

        Generating the extrema of a Cheybshev polynomial of the first kind at
        a given degree.
        """
        if self.degree > 0:
            points = -numpy.cos(
                numpy.pi * numpy.linspace(0, self.degree, self.degree + 1) / self.degree
            )
        else:
            points = numpy.zeros(1)
        self._points = points


class NestedClenshawCurtisPointSet(TieredUnidimensionalPointSet):
    r"""Generate nested Clenshaw Curtis points in accordance with a growth rule

    The :attr:`points` for this interpolation scheme are the extrema of the
    Chebyshev polynomials of the first kind on the domain :math:`[-1, 1]`:

    .. math::

        x_i^* = -\cos(\pi i/n), i = 0,...,n

    For the special case :math:`n = 0`, there is only one point :math:`x_0^* = 0`.

    The nested Clenshaw Curtis points come from the nested extrema of the
    Chebyshev polynomials of the first kind :math:0, 2, 2^{k} where k is an
    integer.

    These extrema are symmetric about 0. When generating levels of points, each
    level with contain a certain number of symmetric pairs except the first which
    also includes 0. The number of points assigned to each level can vary.
    The default, exponential growth adds points such that the new extrema
    calculated from a Chebyshev polynomial 2^{k} is given its own level k-1.
    Alternative growth rules may delay the addition of new extrema and have
    intermediary empty levels, but the general order that points are added to
    levels remains the same.

    This class will generate the nested extrema in the order that corresponds
    to the exponential growth. For increasing k, the unique extrema of Chebyshev
    polynomial with degree 2^{k - 1} will be added followed by the extrema of the
    polynomial with degree 2^{k} , then 2^{k + 1} , then 2^{k + 2} and so on.

    Parameters
    ----------
    max_level ; int
        the maximum level the points are used for
    """

    def __init__(self, max_level):
        super().__init__(max_level)

    @property
    def domain(self):
        """numpy.ndarray: Domain the sample points come from."""
        return numpy.array([-1, 1])

    @property
    def growth_order(self):
        """callable or list: the order of the growth rule."""
        return lambda x: 1 if x == 0 else 2**x + 1

    @property
    def nestedness(self):
        """str: the type of nestedness of the point set."""
        return "fully"

    def _create_points(self):
        r"""Generating the points

        Generating nested extrema of chebyshev polynomials of the first kind.
        """
        points = [0]
        degree = 0
        counter = 0
        for i in range(1, self.max_level + 1):
            counter = counter + 1
            degree = 2**counter
            if counter == 1:
                indexes = numpy.linspace(0, degree, 2, dtype=int)
            else:
                indexes = numpy.linspace(1, degree - 1, degree - 1, dtype=int)
                indexes = indexes[~(numpy.gcd(indexes, degree) > 1)]
            new_points = list(-numpy.cos(numpy.pi * indexes / degree))
            points.extend(new_points)
        self._points = points


class TrigonometricPointSet(UnidimensionalPointSet):
    r"""Set of unidimensional points for Trigonometric sampling

    The :attr:`points` for this interpolation scheme are nested
    trigonometric points

    .. math::

        x^l_j = \frac{j-1}{m(l)},  1 \leq j \leq m(l), l \geq 0

    Parameters
    ----------
    frequency : int
        the frequency to take points from
    """

    def __init__(self, frequency):
        super().__init__()
        self.frequency = frequency

    @property
    def domain(self):
        """numpy.ndarray: Domain the sample points come from."""
        return numpy.array([0, 2 * numpy.pi])

    @property
    def frequency(self):
        """int: frequency to create points for."""
        return self._frequency

    @frequency.setter
    def frequency(self, value):
        self._frequency = value
        self._valid_cache = True

    def _create(self):
        r"""Generating the points

        Generating trigonometic points at a given frequency.
        """
        if self.frequency > 0:
            idx = numpy.linspace(1, self.frequency, self.frequency)
            points = (idx - 1) * 2 * numpy.pi / self.frequency
        else:
            points = numpy.zeros(1)
        self._points = points


class NestedTrigonometricPointSet(TieredUnidimensionalPointSet):
    r"""Set of unidimensional points for Trigonometric sampling

    The :attr:`points` for this interpolation scheme are nested
    trigonometric points

    .. math::

        x^l_j = \frac{j-1}{m(l)},  1 \leq j \leq m(l), l \geq 0

    These points are nested, such that the order of elements in
    `points` corresponds to the indices in `levels`.
    """

    def __init__(self, max_level):
        super().__init__(max_level)

    @property
    def domain(self):
        """numpy.ndarray: Domain the sample points come from."""
        return numpy.array([0, 2 * numpy.pi])

    @property
    def growth_order(self):
        """callable or list: the order of the growth rule."""
        return lambda x: 3**x

    @property
    def nestedness(self):
        """str: the type of nestedness of the point set."""
        return "fully"

    def _create_points(self):
        r"""Generating the points

        Generating the trignometric points using the frequencies
        :math:1, 3, 9, ..., 3^{i} where i is an integer.
        """
        points = []
        degree = 0
        counter = 0
        for i in range(self.max_level + 1):
            degree = 3**counter
            for idx in range(1, degree + 1):
                point = (idx - 1) * 2 * numpy.pi / degree
                if not numpy.isclose(points, point).any():
                    points.append(point)
            counter += 1
        self._points = points
