import scipy.special
import numpy as np


class IndexGrid:
    """
    It is a class for generating indexes of the basis function.

    Attributes
    ----------
    dimension : int
        Number of independent variables.
    exactness : int
        Level of exactness of the approximation.
    index_per_level : list
        Number of indexes at each level (length = exactness + 1)
    """

    def __init__(self, dimension, exactness, index_per_level):
        self.dimension = dimension
        self.exactness = exactness
        self.index_per_level = index_per_level

        if len(index_per_level) != exactness + 1:
            raise IndexError(
                "index_per_level must be of length of {}"
                .format(exactness + 1))

        count_error = 0
        for idx_index_per_level in range(1, self.exactness + 1):
            num_uniq_index = (self.index_per_level[idx_index_per_level]
                              - self.index_per_level[idx_index_per_level-1])
            if num_uniq_index <= 0:
                count_error += 1
                print("Diffrence of indexes at"
                      " level {} and"
                      " level {} must be"
                      " greater than zero".
                      format(idx_index_per_level,
                             idx_index_per_level-1))
        if count_error > 0:
            raise ValueError("Number of indexes generated at level (i) must"
                             " always be less than level (i+1).")

    def uniq_indexes_per_level(self):
        """
        Generate indexes of basis function.

        Unique indexes at each level is generated by considering that
        the basis function generates nested roots at each level.

        Returns
        -------
        level_indexes : numpy array
            Unique indexes at each level.

        """
        # creating an array to store unique indexes in each level
        level_indexes = np.zeros((self.exactness+1), dtype=list)
        # intial level
        max_index = max(self.index_per_level)
        indexes = np.linspace(0, max_index, max_index+1, dtype=np.int32)
        level_indexes[0] = indexes[0:self.index_per_level[0]]

        # storing unique indexes for each level
        for idx_index_per_level in range(1, self.exactness + 1):
            level_indexes[idx_index_per_level] = (
                indexes[self.index_per_level[idx_index_per_level-1]:
                        self.index_per_level[idx_index_per_level]])

        return level_indexes

    def grid_point_index(self):
        """
        Generate index of grid points.

        First, it generates allowed combination of levels via NEXCOM algorithm.
        Then, it replaces the levels with their corresponding index(es), and
        makes the index for all grid points

        Returns
        -------
        grid_points_index : numpy array
            Index of grid points

        """
        level_index_combinations = []
        index_level = self.uniq_indexes_per_level()
        for summ in range(self.dimension, self.exactness+self.dimension+1):
            # NEXCOM
            max_level_index = summ - self.dimension
            num_output = scipy.special.comb(max_level_index+self.dimension-1,
                                            self.dimension-1, exact=True)

            compositions = np.zeros((num_output, self.dimension),
                                    dtype=np.int32)

            # (A) first entry
            r = np.zeros(self.dimension, dtype=np.int32)
            r[0] = max_level_index
            t = max_level_index
            h = 0
            compositions[0] = r
            index = 1

            # (D): these termination conditions should be redundant
            while (r[self.dimension-1] != max_level_index
                   and index < num_output + 1):

                # (B)
                if t != 1:
                    h = 0

                # (C)
                h += 1
                t = r[h-1]
                r[h-1] = 0
                r[0] = t-1
                r[h] += 1

                # (D)
                compositions[index] = r
                index += 1

            # replacing the levels with their corresponding index
            for composition in compositions:
                level_index_combinations.append([])
                for index_i in range(self.dimension):
                    level_index_combinations[-1].append(
                        index_level[composition[index_i]])

        # creating index of grid points
        grid_points_index = []
        for level_index_combination in level_index_combinations:
            len_level = []
            # generating a list containing the number of indexes
            # corresponding to each level
            for level_index in level_index_combination:
                len_level.append(len(level_index))
            # ex. np.ndindex((1,2)) generates (0, 0) and (0, 1)
            for index_dimension_i in np.ndindex(tuple(len_level)):
                for dimension_i in range(self.dimension):
                    index = index_dimension_i[dimension_i]
                    grid_points_index.append(
                        level_index_combination[dimension_i][index])
        grid_points_index = np.array(grid_points_index).reshape(
            (int(len(grid_points_index)/self.dimension), self.dimension))

        return grid_points_index
