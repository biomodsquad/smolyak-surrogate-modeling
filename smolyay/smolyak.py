import numpy


class IndexGrid:
    r"""Indexes of grid points for constructing a surrogate function.

    Create indexes of grid points for generating a surrogate to
    approximate a real function. ``dimension`` represents the number
    of independent variables of the real function, and ``exactness``
    specifies the surrogate's accuracy. Each dimension is assigned
    a level which is integers from 1 to exactness + 1 (maximum level). Levels
    represent indices that correspond to each dimension and
    are chosen as follows:
    ..math::
        ``n`` = ``dimension``
        ``\mu`` = ``exactness``
        ``[k_1, k_2, ..., k_n]`` = ``levels``
        where k_1,2,...,n = [1, 2, ..., ``exactness`` +1]

        ``n`` <= ``k_1 + k_2 + ... + k_n`` <= ``n + \mu``

    For instance:
    ..math::
        if n = 2 and \mu = 1, then:
            if \sum k_i = 2:
                (k_1 = 1, k_2 = 1)
            if \sum k_i = 3:
                (k_1 = 1, k_2 = 2)
                (k_1 = 2, k_2 = 1)

    ``index_per_level`` shows unique roots (corresponding to a
    basis function) needed for each level to construct a surrogate function,
    and one can improve the accuracy by adding new roots at each level.

    For instance: Chebyshev's polynomial of first kind
    ..math::
        ``index_per_level`` = [1, 2, 2, 4, 8, ...]

    The property ``level_indexes`` computes the unique indexes (or number of
    roots)of each level (which then can be replaced by the actual extremums
    depending on a basis function). The property ``grid_point_indexes``
    generates the required number of grid points for constructing
    a surrogate. First, as above, all possible combinations of
    levels are computed, which then can be replaced with indexes.
    Then, grid points are generated by computing all combinations of indexes
    for each combination of levels.

    For instance: Consider ``n`` = 2, ``\mu`` = 1 and Chebyshev's polynomial
    of first kind as the basis fucntion
    ..math::
        ``level_indexes`` = [[0], [1,2]]
        ``level_compositions`` = [([0],[0]), ([0],[1,2]), ([1,2],[0])]
        then:
        ``grid_point_indexes`` = [(0,0), (0,1), (0,2), (1,0), (2,0)]

    Parameters
    ----------
    dimension : int
        Number of independent variables.
    exactness : int
        Level of exactness of the approximation.
    index_per_level : list
        Number of indexes at each level.
    """

    def __init__(self, dimension, exactness, index_per_level):
        self.dimension = dimension
        self.exactness = exactness
        self.index_per_level = index_per_level

    @property
    def dimension(self):
        """int: Dimensionality."""
        return self._dimension

    @dimension.setter
    def dimension(self, value):
        self._dimension = value
        self._needs_update = True

    @property
    def exactness(self):
        """int: Level of exactness."""
        return self._exactness

    @exactness.setter
    def exactness(self, value):
        self._exactness = value
        self._needs_update = True

    @property
    def index_per_level(self):
        """numpy.ndarray: Index per level."""
        return self._index_per_level

    @index_per_level.setter
    def index_per_level(self, value):
        self._index_per_level = numpy.array(value, dtype=int)
        self._needs_update = True

    @property
    def level_indexes(self):
        """Generate indexes of levels."""
        if self._needs_update:
            self._update()

        return self._level_indexes

    @property
    def grid_point_indexes(self):
        """Generate index of grid points."""
        if self._needs_update:
            self._update()

        return self._grid_point_indexes

    def _update(self):
        """Update the indexes of grid points.

        Generates the indexes for each level
        depending on the index_per_level, and makes the
        indexes of grid points.

        Raises
        ------
        IndexError
            Index per level must be an array with a
            length of at least exactness + 1.
        """
        if len(self.index_per_level) < self.exactness + 1:
            raise IndexError(
                "index_per_level must be an array with a"
                " length of at least {}"
                .format(self.exactness + 1))

        # cumulative sum to get end index of each level, up to exactness+1
        end_levels = numpy.cumsum(self.index_per_level[:self.exactness+1])
        # create ranges of indexes at each level
        level_indexes = [list(range(end-n, end))
                         for end, n in zip(end_levels, self.index_per_level)]
        self._level_indexes = level_indexes

        # get all combinations of points at each level
        grid_points_indexes = None
        for sum_of_levels in range(self.dimension,
                                   self.dimension+self.exactness+1):
            for composition in generate_compositions(
                    sum_of_levels, self.dimension, include_zero=False):
                # indexes start from zero
                index_composition = composition - 1
                # generate all combinations of the arrays along each dimension
                level_composition_index = [level_indexes[index]
                                           for index in index_composition]
                grid_points_indexes_ = (numpy.array(
                    numpy.meshgrid(*level_composition_index))
                    .T.reshape(-1, self.dimension))
                if grid_points_indexes is None:
                    grid_points_indexes = grid_points_indexes_
                else:
                    grid_points_indexes = numpy.concatenate(
                        (grid_points_indexes, grid_points_indexes_), axis=0)
        self._grid_point_indexes = grid_points_indexes
        self._needs_update = False


def generate_compositions(value, num_parts, include_zero):
    """Generate compositions of a value into num_parts parts.

    The algorithm that is being used is NEXCOM and can be found in
    "Combinatorial Algorithms For Computers and Calculators",
    Second Edition, 1978.
    Authors: ALBERT NIJENHUIS and HERBERT S. WILF.
    https://doi.org/10.1016/C2013-0-11243-3

    ``include_zero`` parameter determines whether the compositions
    that contain zeros are parts of the output or not.

    The first composition will be (``value``, 0, ..., 0)
    (or (``value-num_parts``, 0, ..., 0) if ``include_zero`` is ``False``).
    Next, the first component (index = 0) is dropped by 1, and next component
    (index = 1) is incremented by 1. This goes on until index 0 reaches ``0``.
    Once, generated all compositions, the  next component is incremented
    by 1 and is fixed until all compositions are generated with the same
    method. This goes on until the last component reaches the ``value``
    (or ``value - num_parts`` if ``include_zero`` is ``False``).
    It is important to note that if ``include_zero`` is ``False``,
    all components will be incremented by 1.

    Parameters
    ----------
    value: int
        Value.
    num_parts: int
        Number of parts.
    include_zero : bool
        True if compositions contain zero, False otherwise.

    Yields
    ------
    numpy.ndarray
        All possible compositions of the value into num_parts.

    Raises
    ------
    ValueError
        Number of parts cannot be greater than value if the desired output
        does not include compositions containing zeroes.
    """
    if value < num_parts:
        raise ValueError(
            "When include_zero is {}, num_parts cannot be greater"
            " than the value"
            .format(False))
    value = value if include_zero else value - num_parts

    # (A) first entry
    r = numpy.zeros(num_parts, dtype=int)
    r[0] = value
    t = value
    h = 0
    yield r if include_zero else r+1

    # (D)
    while r[num_parts-1] != value:
        # (B)
        if t != 1:
            h = 0

        # (C)
        h += 1
        t = r[h-1]
        r[h-1] = 0
        r[0] = t-1
        r[h] += 1
        yield r if include_zero else r+1
