import abc
import numpy
from smolyay.basis import (BasisFunction, ChebyshevFirstKind,
                   BasisFunctionSet, NestedBasisFunctionSet)


class IndexGridGenerator(abc.ABC):
    """Grid points for interpolation.

    Depending on the approach and dimensionality
    , a set of grid points, and their corresponding
    basis functions are generated. These grid points
    and functions can then be then used for approximation
    of complex systems.
    """

    def __init__(self, basis_set):
        self._basis_set = basis_set

    def __call__(self, dimension):
        """Make grid points and their corresponding basis functions.

        Parameters
        ----------
        dimension: int
            Number of idependent variables.

        Returns
        -------
        :class:`IndexGrid`
            Grid points and their corresponding functions.
        """
        pass


class SmolyakGridGenerator(IndexGridGenerator):
    r"""grid points and basis functions for constructing a surrogate.

    Create grid points and their correpsonding basis functions to sample
    complex functions through Smolyak Sparse Sampling method.
    ``nested_basis_set`` is a :class:`NestedBasisSet` which contains
    nested points (points at each level of approximation contains
    the points from all previous level of approximations) and their
    corresponding basis functions, and levels, which indicates
    how points are distributed at each approximation level.
    ``dimension`` represents the number of independent variables of
    the function to be approximated.

    Through Smolyak technique of sampling, each dimension is assigned
    an indicy which is integers from 1 to approximation level + 1
    (The approximation level is called "exactness", and the length of
    the levels, generated by :class:`NestedBasisSet`,
    represents the exactness).

    ..math::
        n: dimensionality
        \mu: exactness
        [k_1, k_2, ..., k_n] = Smolyak indices
        where k_1,2,...,n = [1, 2, ..., exactness +1]
        n <= k_1 + k_2 + ... + k_n <= n + \mu

    For instance:
    ..math::
        if n = 2 and \mu = 1, then:
            if \sum{1}^{n} k_i = 2:
                (k_1 = 1, k_2 = 1)
            if \sum k_i{i=1}^{n} = 3:
                (k_1 = 1, k_2 = 2)
                (k_1 = 2, k_2 = 1)

    The  :meth:`smolyak_indices` generates the mentioned compositions,
    and can expand or drop indices if necessary.
    The :meth:`make_integer_grid_points` generates the indexes of
    grid points (integer grids) depending on dimensionality and
    exactness. First, as above, all possible combinations of
    indices are computed, which then can be replaced with indexes based on the
    levels. Then, grid points are generated by making all combinations of
    indexes for each combination of levels' indices.

    Once integer grid points are generated, actual grid points
    (``grid_points``) and their corresponding basis functions
    (``grid_points_basis``) can be made by simply replacing
    the indexes with their corresponding points and basis functions.

    :meth:`_update` updates the integer grid points, grid points and
    their corresponding functions.

    Parameters
    ----------
    nested_basis_set: :class:`NestedBasisSet`
        points, basis functions and levels.

    Example
    -------
    For instance: Consider dimension (or n) = 2, and
    exactness (or \mu) = 1 and Chebyshev's polynomial
    of first kind, and its extremums as the basis function and points, then:
    ..math::
        levels = [[0], [1,2]]
        level compositions = [([0],[0]), ([0],[1,2]), ([1,2],[0])]
        then:
        grid points indexes = [(0,0), (0,1), (0,2), (1,0), (2,0)]
        points = [0, -1, 1]
        basis = [:class:`ChebyshevFunction`, ::class:`ChebyshevFunction`,
                 :class:`ChebyshevFunction`]

    Then:
    ..math:
        grid_points = [(0, 0), (0, -1), (0, 1), (-1, 0), (1, 0)]
        grid points' functions = [(:class:`ChebyshevFunction`,
        :class:`ChebyshevFunction`)
        , (:class:`ChebyshevFunction`, :class:`ChebyshevFunction`),
        (:class:`ChebyshevFunction`, :class:`ChebyshevFunction`),
        (:class:`ChebyshevFunction`, :class:`ChebyshevFunction`),
        (:class:`ChebyshevFunction`, :class:`ChebyshevFunction`)]

    """

    def __init__(self, nested_basis_set):
        self._nested_basis_set = nested_basis_set
        self._points = self._nested_basis_set.points
        self._basis = self._nested_basis_set.basis_functions
        self._levels = self._nested_basis_set.levels

    @property
    def nested_basis_set(self):
        """:class:`NestedBasisSet`: Nested basis set (data structure)."""
        return self._nested_basis_set

    @nested_basis_set.setter
    def nested_basis_set(self, nested_basis_set):
        self._nested_basis_set = nested_basis_set

    def make_integer_grid_points(self, dimension):
        """Generate grid points based on their indexes via Smolyak method.

        Parameters
        ----------
        dimension: int
            Number of independent variables.

        Returns
        -------
        list
            Integer grid points.
        """
        self._update(dimension)
        return self._grid_points_indexes

    def smolyak_indices(self, dimension, expand_indicy=[], drop_indicy=[]):
        """Generate Smolyak indices depending on the dimensionality.

        Parameters
        ----------
        dimension: int
            Number of independent variables.
        expand_indicy: iterator
            Indicy that is needed to be added.
        drop_indicy: iterator
            Indicy that is needed to be dropped.

        Returns
        -------
        list
            Smolyak indices.

        Raises
        ------
        IndexError
            Indicy that is needed to be added or dropped must be in
            length of the dimension.
        """
        self._expand_indicy = expand_indicy
        self._drop_indicy = drop_indicy
        self._update(dimension)

        if ((self._drop_indicy != [] and len(self._drop_indicy) != dimension)
            or (self._expand_indicy != [] and
                len(self._expand_indicy) != dimension)):
            raise IndexError("Indicy must be in length of the dimension.")

        if (self._drop_indicy != [] and
           self._drop_indicy not in self._smolyak_indices):
            raise ValueError("Indicy doesn't exist.")

        if self._expand_indicy == [] and self._drop_indicy == []:
            return self._smolyak_indices
        else:
            if self._expand_indicy == []:
                self._smolyak_indices.remove(drop_indicy)
            elif self._drop_indicy == []:
                self._smolyak_indices.append(expand_indicy)
            else:
                self._smolyak_indices.append(expand_indicy)
                self._smolyak_indices.remove(drop_indicy)
            return self._smolyak_indices

    def __call__(self, dimension):
        """Make grid points and their corresponding basis functions.

        Depending on the dimensionality, a set of grid points are generated
        based on their polynomial degree (integer grid points). Grid points of
        the basis function (bounded between -1 and 1), and their corresponding
        basis function are generated.

        Parameters
        ----------
        dimension: int
            Number of independent variables

        Returns
        -------
        :class:`IndexGrid`
            Grid points and their corresponding functions.
        """
        self._dimension = dimension
        self._update(self._dimension)

        return IndexGrid(self._grid_points, self._grid_points_basis)

    def _update(self, dimension):
        """Update the properties associated with Smolyak sampling method.

        Update the grid points (and their integers), basis functions and
        indicies.

        Parameters
        ----------
        dimension: int
            Number of independent variables
        """
        self._dimension = dimension
        grid_points_indexes = None
        self._smolyak_indices = []
        for sum_of_levels in range(self._dimension,
                                   self._dimension+len(self._levels)):
            for composition in generate_compositions(
                    sum_of_levels, self._dimension, include_zero=False):
                self._smolyak_indices.append(composition)
                # indexes start from zero
                index_composition = numpy.array(composition) - 1
                # generate all combinations of
                # the arrays along each dimension
                level_composition_index = [self._levels[index]
                                           for index in index_composition]
                grid_points_indexes_ = (numpy.array(
                    numpy.meshgrid(*level_composition_index))
                    .T.reshape(-1, self._dimension))
                if grid_points_indexes is None:
                    grid_points_indexes = grid_points_indexes_
                else:
                    grid_points_indexes = numpy.concatenate(
                        (grid_points_indexes,
                         grid_points_indexes_), axis=0)
        # make integer grids, grid points and basis functions
        self._grid_points_indexes = grid_points_indexes.tolist()
        self._grid_points = numpy.array(self._points
                                        )[grid_points_indexes].tolist()
        self._grid_points_basis = numpy.array(self._basis)[
                                                grid_points_indexes].tolist()


class IndexGrid():
    """Set of grid points and their corresponding functions (a data structure).

    Generate a data structure that contains grid points
    and their corresponding basis functions. This data structure
    can then be used to generate a surrogate for complex systems.
    """

    def __init__(self, grid_points, grid_points_basis):
        self._grid_points = grid_points
        self._grid_points_basis = grid_points_basis

    @property
    def grid_points(self):
        """list: Grid points bounded between (-1, 1)."""
        return self._grid_points

    @property
    def grid_points_basis(self):
        """list: Basis functions of grid points."""
        return self._grid_points_basis


def generate_compositions(value, num_parts, include_zero):
    """Generate compositions of a value into num_parts parts.

    The algorithm that is being used is NEXCOM and can be found in
    "Combinatorial Algorithms For Computers and Calculators",
    Second Edition, 1978.
    Authors: ALBERT NIJENHUIS and HERBERT S. WILF.
    https://doi.org/10.1016/C2013-0-11243-3
    ``include_zero`` parameter determines whether the compositions
    that contain zeros are parts of the output or not.
    The first composition will be (``value``, 0, ..., 0)
    (or (``value-num_parts``, 0, ..., 0) if ``include_zero`` is ``False``).
    Next, the first component (index = 0) is dropped by 1, and next component
    (index = 1) is incremented by 1. This goes on until index 0 reaches ``0``.
    Once, generated all compositions, the  next component is incremented
    by 1 and is fixed until all compositions are generated with the same
    method. This goes on until the last component reaches the ``value``
    (or ``value - num_parts`` if ``include_zero`` is ``False``).
    It is important to note that if ``include_zero`` is ``False``,
    all components will be incremented by 1.

    Parameters
    ----------
    value: int
        Value.
    num_parts: int
        Number of parts.
    include_zero : bool
        True if compositions contain zero, False otherwise.

    Yields
    ------
    list
        All possible compositions of the value into num_parts.

    Raises
    ------
    ValueError
        Number of parts cannot be greater than value if the desired output
        does not include compositions containing zeroes.
    """
    if value < num_parts and include_zero is False:
        raise ValueError(
            "When include_zero is {}, num_parts cannot be greater"
            " than the value"
            .format(False))
    value = value if include_zero else value - num_parts

    # (A) first entry
    r = [0]*num_parts
    r[0] = value
    t = value
    h = 0
    yield list(r) if include_zero else (numpy.array(r)+1).tolist()

    # (D)
    while r[num_parts-1] != value:
        # (B)
        if t != 1:
            h = 0

        # (C)
        h += 1
        t = r[h-1]
        r[h-1] = 0
        r[0] = t-1
        r[h] += 1
        yield list(r) if include_zero else (numpy.array(r)+1).tolist()
